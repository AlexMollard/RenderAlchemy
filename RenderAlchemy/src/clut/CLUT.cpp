#include "CLUT.h"

#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdexcept>

#include "../renderer/BgfxUtils.h"

CLUT::CLUT()
      : name(""), size(0), is3D(false)
{
}

CLUT::CLUT(const std::string& name, const std::vector<float>& data, int size, bool is3D)
      : name(name), data(data), size(size), is3D(is3D)
{
}

const std::string& CLUT::getName() const
{
	return name;
}

const std::vector<float>& CLUT::getData() const
{
	return data;
}

int CLUT::getSize() const
{
	return size;
}

bool CLUT::is3DCLUT() const
{
	return is3D;
}

void CLUT::setName(const std::string& name)
{
	this->name = name;
}

void CLUT::setData(const std::vector<float>& data)
{
	this->data = data;
}

void CLUT::setSize(int size)
{
	this->size = size;
}

void CLUT::setIs3DCLUT(bool is3D)
{
	this->is3D = is3D;
}

void CLUT::saveToFile(const std::string& filename) const
{
	std::ofstream file(filename);
	if (!file.is_open())
	{
		throw std::runtime_error("Failed to open file for writing: " + filename);
	}

	// Write header
	file << "# CLUT generated by CLUT Library\n";
	file << "# Title: " << name << "\n";

	if (is3D)
	{
		// 3D CLUT header
		file << "LUT_3D_SIZE " << size << "\n\n";

		// Write 3D CLUT data in standard .cube format
		for (int b = 0; b < size; b++)
		{
			for (int g = 0; g < size; g++)
			{
				for (int r = 0; r < size; r++)
				{
					int idx = (b * size * size + g * size + r) * 3;
					float rVal = data[idx + 0];
					float gVal = data[idx + 1];
					float bVal = data[idx + 2];

					file << rVal << " " << gVal << " " << bVal << "\n";
				}
			}
		}
	}
	else
	{
		// 1D CLUT header
		file << "# 1D CLUT\n";
		file << "LUT_1D_SIZE " << size << "\n\n";

		// Write 1D CLUT data
		for (int i = 0; i < size; i++)
		{
			float r = data[i * 3];
			float g = data[i * 3 + 1];
			float b = data[i * 3 + 2];

			file << r << " " << g << " " << b << "\n";
		}
	}

	file.close();
}

CLUT CLUT::loadFromFile(const std::string& filename)
{
	std::ifstream file(filename);
	if (!file.is_open())
	{
		throw std::runtime_error("Failed to open CLUT file: " + filename);
	}

	CLUT result;
	result.name = filename.substr(filename.find_last_of("/\\") + 1);
	result.name = result.name.substr(0, result.name.find_last_of('.'));

	std::string line;
	bool readingData = false;
	bool is3DLUT = false;
	bool is1DLUT = false;

	// Read header
	while (std::getline(file, line) && !readingData)
	{
		// Skip comments
		if (line.empty() || line[0] == '#')
			continue;

		// Check for LUT size declaration
		if (line.find("LUT_3D_SIZE") != std::string::npos)
		{
			std::istringstream iss(line);
			std::string token;
			int size;
			iss >> token >> size;
			result.size = size;
			result.is3D = true;
			is3DLUT = true;
			readingData = true;
		}
		else if (line.find("LUT_1D_SIZE") != std::string::npos)
		{
			std::istringstream iss(line);
			std::string token;
			int size;
			iss >> token >> size;
			result.size = size;
			result.is3D = false;
			is1DLUT = true;
			readingData = true;
		}
	}

	if (result.size <= 0)
	{
		// Try to detect the type of LUT based on number of entries
		std::vector<std::string> lines;
		lines.push_back(line); // Add the first line already read

		while (std::getline(file, line))
		{
			if (!line.empty() && line[0] != '#')
			{
				lines.push_back(line);
			}
		}

		// Reset file pointer to beginning
		file.clear();
		file.seekg(0, std::ios::beg);

		int entries = lines.size();

		// Guess if this is a 3D LUT based on common sizes
		if (entries == 4913)
		{ // 17続
			result.size = 17;
			result.is3D = true;
		}
		else if (entries == 4096)
		{ // 16続
			result.size = 16;
			result.is3D = true;
		}
		else if (entries == 729)
		{ // 9続
			result.size = 9;
			result.is3D = true;
		}
		else if (entries == 512)
		{ // 8続
			result.size = 8;
			result.is3D = true;
		}
		else
		{
			// Default to 1D LUT
			result.size = entries;
			result.is3D = false;
		}

		// Skip header again to read data
		readingData = false;
		while (std::getline(file, line) && !readingData)
		{
			if (line.empty() || line[0] == '#')
				continue;
			readingData = true;
		}
	}

	// Allocate space for data
	if (result.is3D)
	{
		result.data.resize(result.size * result.size * result.size * 3);
	}
	else
	{
		result.data.resize(result.size * 3);
	}

	// Read data
	int index = 0;

	// Process the first line of data (already read)
	if (readingData)
	{
		std::istringstream iss(line);
		float r, g, b;
		iss >> r >> g >> b;

		result.data[index++] = r;
		result.data[index++] = g;
		result.data[index++] = b;
	}

	// Read the rest of the data
	while (std::getline(file, line))
	{
		// Skip comments and empty lines
		if (line.empty() || line[0] == '#')
			continue;

		std::istringstream iss(line);
		float r, g, b;
		iss >> r >> g >> b;

		if (index < result.data.size())
		{
			result.data[index++] = r;
			result.data[index++] = g;
			result.data[index++] = b;
		}
	}

	// Check if we have enough data
	if (index != result.data.size())
	{
		throw std::runtime_error("Invalid CLUT file: data size doesn't match expected size");
	}

	return result;
}

bgfx::TextureHandle CLUT::create1DTexture() const
{
	if (is3D)
	{
		throw std::runtime_error("Attempted to create 1D texture from 3D CLUT data");
	}

	// Create bgfx texture
	bgfx::TextureHandle texture = bgfx::createTexture2D(size, 1, false, 1, bgfx::TextureFormat::RGBA32F, BGFX_TEXTURE_NONE, bgfx::copy(data.data(), size * 3 * sizeof(float)));

	if (!bgfx::isValid(texture))
	{
		throw std::runtime_error("bgfx error while creating 1D CLUT texture");
	}

	return texture;
}

bgfx::TextureHandle CLUT::create3DTexture() const
{
	if (!is3D)
	{
		throw std::runtime_error("Attempted to create 3D texture from 1D CLUT data");
	}

	// Create bgfx texture
	bgfx::TextureHandle texture = bgfx::createTexture3D(size, size, size, false, bgfx::TextureFormat::RGBA32F, BGFX_TEXTURE_NONE, bgfx::copy(data.data(), size * size * size * 3 * sizeof(float)));

	if (!bgfx::isValid(texture))
	{
		throw std::runtime_error("bgfx error while creating 3D CLUT texture");
	}

	return texture;
}

bgfx::TextureHandle CLUT::create1DCLUT(const std::vector<float>& clutData, int size)
{
	// Create bgfx texture
	bgfx::TextureHandle texture = bgfx::createTexture2D(size, 1, false, 1, bgfx::TextureFormat::RGBA32F, BGFX_TEXTURE_NONE, bgfx::copy(clutData.data(), size * 3 * sizeof(float)));

	if (!bgfx::isValid(texture))
	{
		throw std::runtime_error("bgfx error while creating 1D CLUT texture");
	}

	return texture;
}

bgfx::TextureHandle CLUT::create3DCLUT(const std::vector<float>& clutData, int size)
{
	// Create bgfx texture
	bgfx::TextureHandle texture = bgfx::createTexture3D(size, size, size, false, bgfx::TextureFormat::RGBA32F, BGFX_TEXTURE_NONE, bgfx::copy(clutData.data(), size * size * size * 3 * sizeof(float)));

	if (!bgfx::isValid(texture))
	{
		throw std::runtime_error("bgfx error while creating 3D CLUT texture");
	}

	return texture;
}

void CLUT::createPreset1DCLUTs(std::map<std::string, CLUT>& clutLibrary)
{
	// --- 1D CLUTs ---

	// Neutral 1D CLUT (identity mapping)
	CLUT neutral;
	neutral.name = "Neutral (1D)";
	neutral.size = 64;
	neutral.is3D = false;
	neutral.data.resize(neutral.size * 3);

	for (int i = 0; i < neutral.size; i++)
	{
		float t = static_cast<float>(i) / (neutral.size - 1);
		neutral.data[i * 3] = t;
		neutral.data[i * 3 + 1] = t;
		neutral.data[i * 3 + 2] = t;
	}
	clutLibrary["Neutral (1D)"] = neutral;

	// Film-like 1D CLUT
	CLUT film;
	film.name = "Film (1D)";
	film.size = 64;
	film.is3D = false;
	film.data.resize(film.size * 3);

	for (int i = 0; i < film.size; i++)
	{
		float t = static_cast<float>(i) / (film.size - 1);

		if (t < 0.2f)
		{
			// Crushed shadows with blue tint
			film.data[i * 3] = t * 0.7f;     // R
			film.data[i * 3 + 1] = t * 0.8f; // G
			film.data[i * 3 + 2] = t * 0.9f; // B
		}
		else if (t < 0.5f)
		{
			// Midtones with slightly warm look
			float u = (t - 0.2f) / 0.3f;
			film.data[i * 3] = 0.14f + u * 0.5f;     // R
			film.data[i * 3 + 1] = 0.16f + u * 0.5f; // G
			film.data[i * 3 + 2] = 0.18f + u * 0.4f; // B
		}
		else if (t < 0.8f)
		{
			// Upper midtones with orange/yellow tint
			float u = (t - 0.5f) / 0.3f;
			film.data[i * 3] = 0.64f + u * 0.25f;    // R
			film.data[i * 3 + 1] = 0.66f + u * 0.2f; // G
			film.data[i * 3 + 2] = 0.58f + u * 0.1f; // B
		}
		else
		{
			// Highlights bloom slightly
			float u = (t - 0.8f) / 0.2f;
			film.data[i * 3] = 0.89f + u * 0.11f;     // R
			film.data[i * 3 + 1] = 0.86f + u * 0.14f; // G
			film.data[i * 3 + 2] = 0.68f + u * 0.32f; // B
		}
	}
	clutLibrary["Film (1D)"] = film;

	// Cool 1D CLUT
	CLUT cool;
	cool.name = "Cool (1D)";
	cool.size = 64;
	cool.is3D = false;
	cool.data.resize(cool.size * 3);

	for (int i = 0; i < cool.size; i++)
	{
		float t = static_cast<float>(i) / (cool.size - 1);

		// Cool blue-teal palette
		cool.data[i * 3] = t * 0.7f;                     // R
		cool.data[i * 3 + 1] = t * 0.9f;                 // G
		cool.data[i * 3 + 2] = std::min(1.0f, t * 1.1f); // B
	}
	clutLibrary["Cool (1D)"] = cool;

	// Warm 1D CLUT
	CLUT warm;
	warm.name = "Warm (1D)";
	warm.size = 64;
	warm.is3D = false;
	warm.data.resize(warm.size * 3);

	for (int i = 0; i < warm.size; i++)
	{
		float t = static_cast<float>(i) / (warm.size - 1);

		// Warm amber palette
		warm.data[i * 3] = std::min(1.0f, t * 1.2f); // R
		warm.data[i * 3 + 1] = t * 0.8f;             // G
		warm.data[i * 3 + 2] = t * 0.6f;             // B
	}
	clutLibrary["Warm (1D)"] = warm;

	// High Contrast 1D CLUT
	CLUT highContrast;
	highContrast.name = "High Contrast (1D)";
	highContrast.size = 64;
	highContrast.is3D = false;
	highContrast.data.resize(highContrast.size * 3);

	for (int i = 0; i < highContrast.size; i++)
	{
		float t = static_cast<float>(i) / (highContrast.size - 1);

		// Apply contrast curve (S-curve)
		float contrastT = 0.5f * (1.0f - std::cos(t * 3.14159f));
		contrastT = std::pow(contrastT, 1.5f);

		highContrast.data[i * 3] = contrastT;     // R
		highContrast.data[i * 3 + 1] = contrastT; // G
		highContrast.data[i * 3 + 2] = contrastT; // B
	}
	clutLibrary["High Contrast (1D)"] = highContrast;

	// Vintage 1D CLUT
	CLUT vintage;
	vintage.name = "Vintage (1D)";
	vintage.size = 64;
	vintage.is3D = false;
	vintage.data.resize(vintage.size * 3);

	for (int i = 0; i < vintage.size; i++)
	{
		float t = static_cast<float>(i) / (vintage.size - 1);

		// Vintage look with faded colors and slight red/yellow tint
		vintage.data[i * 3] = std::min(1.0f, 0.1f + t * 0.9f);     // R
		vintage.data[i * 3 + 1] = std::min(1.0f, 0.1f + t * 0.8f); // G
		vintage.data[i * 3 + 2] = std::min(1.0f, 0.2f + t * 0.6f); // B
	}
	clutLibrary["Vintage (1D)"] = vintage;

	// Sepia 1D CLUT
	CLUT sepia;
	sepia.name = "Sepia (1D)";
	sepia.size = 64;
	sepia.is3D = false;
	sepia.data.resize(sepia.size * 3);

	for (int i = 0; i < sepia.size; i++)
	{
		float t = static_cast<float>(i) / (sepia.size - 1);

		// Sepia tones
		sepia.data[i * 3] = std::min(1.0f, t * 1.1f); // R
		sepia.data[i * 3 + 1] = t * 0.8f;             // G
		sepia.data[i * 3 + 2] = t * 0.5f;             // B
	}
	clutLibrary["Sepia (1D)"] = sepia;

	// Night Vision 1D CLUT
	CLUT nightVision;
	nightVision.name = "Night Vision (1D)";
	nightVision.size = 64;
	nightVision.is3D = false;
	nightVision.data.resize(nightVision.size * 3);

	for (int i = 0; i < nightVision.size; i++)
	{
		float t = static_cast<float>(i) / (nightVision.size - 1);

		// Green night vision
		nightVision.data[i * 3] = t * 0.2f;     // R
		nightVision.data[i * 3 + 1] = t * 1.0f; // G
		nightVision.data[i * 3 + 2] = t * 0.2f; // B
	}
	clutLibrary["Night Vision (1D)"] = nightVision;

	// Noir 1D CLUT
	CLUT noir;
	noir.name = "Noir (1D)";
	noir.size = 64;
	noir.is3D = false;
	noir.data.resize(noir.size * 3);

	for (int i = 0; i < noir.size; i++)
	{
		float t = static_cast<float>(i) / (noir.size - 1);

		// High contrast black and white
		float contrastT = std::pow(t, 1.5f);
		noir.data[i * 3] = contrastT;     // R
		noir.data[i * 3 + 1] = contrastT; // G
		noir.data[i * 3 + 2] = contrastT; // B
	}
	clutLibrary["Noir (1D)"] = noir;

	// Toon 1D CLUT
	CLUT toon;
	toon.name = "Toon (1D)";
	toon.size = 64;
	toon.is3D = false;
	toon.data.resize(toon.size * 3);

	// Define number of steps (bands) for cel shading effect
	const int numBands = 6;

	for (int i = 0; i < toon.size; i++)
	{
		float t = static_cast<float>(i) / (toon.size - 1);

		// Quantize the value to create distinct color bands
		float quantized = std::floor(t * numBands) / (numBands - 1);

		// Add slight boost to emphasize edges between bands
		float boosted = std::min(1.0f, quantized * 1.05f);

		toon.data[i * 3] = boosted;     // R
		toon.data[i * 3 + 1] = boosted; // G
		toon.data[i * 3 + 2] = boosted; // B
	}
	clutLibrary["Toon (1D)"] = toon;
}

void CLUT::createPreset3DCLUTs(std::map<std::string, CLUT>& clutLibrary)
{
	// --- 3D CLUTs ---

	// Neutral 3D CLUT (identity mapping)
	CLUT neutral3D;
	neutral3D.name = "Neutral (3D)";
	neutral3D.size = 16; // Typical size for 3D LUTs
	neutral3D.is3D = true;
	neutral3D.data.resize(neutral3D.size * neutral3D.size * neutral3D.size * 3);

	for (int b = 0; b < neutral3D.size; b++)
	{
		for (int g = 0; g < neutral3D.size; g++)
		{
			for (int r = 0; r < neutral3D.size; r++)
			{
				int idx = (b * neutral3D.size * neutral3D.size + g * neutral3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (neutral3D.size - 1);
				float gNorm = static_cast<float>(g) / (neutral3D.size - 1);
				float bNorm = static_cast<float>(b) / (neutral3D.size - 1);

				neutral3D.data[idx + 0] = rNorm;
				neutral3D.data[idx + 1] = gNorm;
				neutral3D.data[idx + 2] = bNorm;
			}
		}
	}
	clutLibrary["Neutral (3D)"] = neutral3D;

	// Cinematic 3D CLUT
	CLUT cinematic3D;
	cinematic3D.name = "Cinematic (3D)";
	cinematic3D.size = 16;
	cinematic3D.is3D = true;
	cinematic3D.data.resize(cinematic3D.size * cinematic3D.size * cinematic3D.size * 3);

	for (int b = 0; b < cinematic3D.size; b++)
	{
		for (int g = 0; g < cinematic3D.size; g++)
		{
			for (int r = 0; r < cinematic3D.size; r++)
			{
				int idx = (b * cinematic3D.size * cinematic3D.size + g * cinematic3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (cinematic3D.size - 1);
				float gNorm = static_cast<float>(g) / (cinematic3D.size - 1);
				float bNorm = static_cast<float>(b) / (cinematic3D.size - 1);

				// Boost shadows and midtones in blue channel
				float bNew = std::pow(bNorm, 0.85f);

				// Warm up highlights
				float rNew = rNorm * 1.05f;
				if (rNorm > 0.7f)
				{
					rNew = rNorm * 1.1f;
				}

				// Increase contrast slightly
				float contrast = 1.1f;
				rNew = 0.5f + (rNew - 0.5f) * contrast;
				gNorm = 0.5f + (gNorm - 0.5f) * contrast;
				bNew = 0.5f + (bNew - 0.5f) * contrast;

				// Add subtle orange-teal color scheme
				if (rNorm > 0.6f && gNorm > 0.6f)
				{
					// Warm highlights
					rNew = std::min(1.0f, rNew * 1.1f);
					gNorm = std::min(1.0f, gNorm * 1.05f);
					bNew = std::max(0.0f, bNew * 0.95f);
				}
				else if (bNorm > 0.5f)
				{
					// Cooler shadows
					rNew = std::max(0.0f, rNew * 0.95f);
					bNew = std::min(1.0f, bNew * 1.05f);
				}

				cinematic3D.data[idx + 0] = std::max(0.0f, std::min(1.0f, rNew));
				cinematic3D.data[idx + 1] = std::max(0.0f, std::min(1.0f, gNorm));
				cinematic3D.data[idx + 2] = std::max(0.0f, std::min(1.0f, bNew));
			}
		}
	}
	clutLibrary["Cinematic (3D)"] = cinematic3D;

	// Cross-processed 3D CLUT
	CLUT crossProcess3D;
	crossProcess3D.name = "Cross Processed (3D)";
	crossProcess3D.size = 16;
	crossProcess3D.is3D = true;
	crossProcess3D.data.resize(crossProcess3D.size * crossProcess3D.size * crossProcess3D.size * 3);

	for (int b = 0; b < crossProcess3D.size; b++)
	{
		for (int g = 0; g < crossProcess3D.size; g++)
		{
			for (int r = 0; r < crossProcess3D.size; r++)
			{
				int idx = (b * crossProcess3D.size * crossProcess3D.size + g * crossProcess3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (crossProcess3D.size - 1);
				float gNorm = static_cast<float>(g) / (crossProcess3D.size - 1);
				float bNorm = static_cast<float>(b) / (crossProcess3D.size - 1);

				// Cross-processing effect (mimics developing C41 film in E6 chemicals or vice versa)
				float rNew, gNew, bNew;

				// Increase contrast
				rNorm = 0.5f + (rNorm - 0.5f) * 1.3f;
				gNorm = 0.5f + (gNorm - 0.5f) * 1.3f;
				bNorm = 0.5f + (bNorm - 0.5f) * 1.3f;

				rNorm = std::max(0.0f, std::min(1.0f, rNorm));
				gNorm = std::max(0.0f, std::min(1.0f, gNorm));
				bNorm = std::max(0.0f, std::min(1.0f, bNorm));

				// Cyan in shadows, yellow in highlights
				if (rNorm + gNorm + bNorm < 1.5f)
				{
					// Shadows to cyan
					rNew = rNorm * 0.8f;
					gNew = gNorm * 1.1f;
					bNew = bNorm * 1.2f;
				}
				else
				{
					// Highlights to yellow
					rNew = rNorm * 1.2f;
					gNew = gNorm * 1.1f;
					bNew = bNorm * 0.7f;
				}

				crossProcess3D.data[idx + 0] = std::max(0.0f, std::min(1.0f, rNew));
				crossProcess3D.data[idx + 1] = std::max(0.0f, std::min(1.0f, gNew));
				crossProcess3D.data[idx + 2] = std::max(0.0f, std::min(1.0f, bNew));
			}
		}
	}
	clutLibrary["Cross Processed (3D)"] = crossProcess3D;

	// Bleach Bypass 3D CLUT
	CLUT bleachBypass3D;
	bleachBypass3D.name = "Bleach Bypass (3D)";
	bleachBypass3D.size = 16;
	bleachBypass3D.is3D = true;
	bleachBypass3D.data.resize(bleachBypass3D.size * bleachBypass3D.size * bleachBypass3D.size * 3);

	for (int b = 0; b < bleachBypass3D.size; b++)
	{
		for (int g = 0; g < bleachBypass3D.size; g++)
		{
			for (int r = 0; r < bleachBypass3D.size; r++)
			{
				int idx = (b * bleachBypass3D.size * bleachBypass3D.size + g * bleachBypass3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (bleachBypass3D.size - 1);
				float gNorm = static_cast<float>(g) / (bleachBypass3D.size - 1);
				float bNorm = static_cast<float>(b) / (bleachBypass3D.size - 1);

				// Calculate luminance
				float luminance = 0.2126f * rNorm + 0.7152f * gNorm + 0.0722f * bNorm;

				// Bleach bypass - desaturate and increase contrast
				float desaturationAmount = 0.6f;
				float contrastAmount = 1.5f;

				// Blend desaturated and original
				float rNew = rNorm * (1.0f - desaturationAmount) + luminance * desaturationAmount;
				float gNew = gNorm * (1.0f - desaturationAmount) + luminance * desaturationAmount;
				float bNew = bNorm * (1.0f - desaturationAmount) + luminance * desaturationAmount;

				// Apply contrast
				rNew = 0.5f + (rNew - 0.5f) * contrastAmount;
				gNew = 0.5f + (gNew - 0.5f) * contrastAmount;
				bNew = 0.5f + (bNew - 0.5f) * contrastAmount;

				// Add slight blue to shadows and yellow/orange to highlights
				if (luminance < 0.5f)
				{
					bNew = std::min(1.0f, bNew * 1.1f);
				}
				else
				{
					rNew = std::min(1.0f, rNew * 1.1f);
					gNew = std::min(1.0f, gNew * 1.05f);
				}

				bleachBypass3D.data[idx + 0] = std::max(0.0f, std::min(1.0f, rNew));
				bleachBypass3D.data[idx + 1] = std::max(0.0f, std::min(1.0f, gNew));
				bleachBypass3D.data[idx + 2] = std::max(0.0f, std::min(1.0f, bNew));
			}
		}
	}
	clutLibrary["Bleach Bypass (3D)"] = bleachBypass3D;

	// Teal and Orange 3D CLUT
	CLUT tealOrange3D;
	tealOrange3D.name = "Teal and Orange (3D)";
	tealOrange3D.size = 16;
	tealOrange3D.is3D = true;
	tealOrange3D.data.resize(tealOrange3D.size * tealOrange3D.size * tealOrange3D.size * 3);

	for (int b = 0; b < tealOrange3D.size; b++)
	{
		for (int g = 0; g < tealOrange3D.size; g++)
		{
			for (int r = 0; r < tealOrange3D.size; r++)
			{
				int idx = (b * tealOrange3D.size * tealOrange3D.size + g * tealOrange3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (tealOrange3D.size - 1);
				float gNorm = static_cast<float>(g) / (tealOrange3D.size - 1);
				float bNorm = static_cast<float>(b) / (tealOrange3D.size - 1);

				// Calculate luminance
				float luminance = 0.2126f * rNorm + 0.7152f * gNorm + 0.0722f * bNorm;

				// Push shadows towards teal and highlights towards orange
				float rNew = rNorm;
				float gNew = gNorm;
				float bNew = bNorm;

				if (luminance < 0.5f)
				{
					// Shadows to teal (reduce red, boost blue and green)
					rNew *= 0.8f;
					gNew *= 1.1f;
					bNew *= 1.2f;
				}
				else
				{
					// Highlights to orange (boost red and green, reduce blue)
					rNew *= 1.3f;
					gNew *= 1.1f;
					bNew *= 0.6f;
				}

				// Increase contrast overall
				rNew = 0.5f + (rNew - 0.5f) * 1.2f;
				gNew = 0.5f + (gNew - 0.5f) * 1.2f;
				bNew = 0.5f + (bNew - 0.5f) * 1.2f;

				tealOrange3D.data[idx + 0] = std::max(0.0f, std::min(1.0f, rNew));
				tealOrange3D.data[idx + 1] = std::max(0.0f, std::min(1.0f, gNew));
				tealOrange3D.data[idx + 2] = std::max(0.0f, std::min(1.0f, bNew));
			}
		}
	}
	clutLibrary["Teal and Orange (3D)"] = tealOrange3D;

	// Fujifilm Pro 400H 3D CLUT (film emulation)
	CLUT fujiPro3D;
	fujiPro3D.name = "Fujifilm Pro 400H (3D)";
	fujiPro3D.size = 16;
	fujiPro3D.is3D = true;
	fujiPro3D.data.resize(fujiPro3D.size * fujiPro3D.size * fujiPro3D.size * 3);

	for (int b = 0; b < fujiPro3D.size; b++)
	{
		for (int g = 0; g < fujiPro3D.size; g++)
		{
			for (int r = 0; r < fujiPro3D.size; r++)
			{
				int idx = (b * fujiPro3D.size * fujiPro3D.size + g * fujiPro3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (fujiPro3D.size - 1);
				float gNorm = static_cast<float>(g) / (fujiPro3D.size - 1);
				float bNorm = static_cast<float>(b) / (fujiPro3D.size - 1);

				// Fuji Pro 400H is known for its subtle pastel colors and slightly greenish midtones
				float rNew = rNorm;
				float gNew = gNorm;
				float bNew = bNorm;

				// Softer contrast in shadows
				if (rNorm < 0.3f)
					rNew = rNorm * 1.1f;
				if (gNorm < 0.3f)
					gNew = gNorm * 1.05f;
				if (bNorm < 0.3f)
					bNew = bNorm * 1.1f;

				// Greenish-blue tint in midtones
				if (rNorm >= 0.3f && rNorm < 0.7f)
				{
					gNew = std::min(1.0f, gNorm * 1.05f);
					bNew = std::min(1.0f, bNorm * 1.03f);
				}

				// Soft pastel highlights with a subtle purple tint
				if (rNorm >= 0.7f)
				{
					rNew = std::min(1.0f, 0.9f + (rNorm - 0.7f) * 0.33f);
					bNew = std::min(1.0f, bNorm * 1.1f);
				}

				fujiPro3D.data[idx + 0] = std::max(0.0f, std::min(1.0f, rNew));
				fujiPro3D.data[idx + 1] = std::max(0.0f, std::min(1.0f, gNew));
				fujiPro3D.data[idx + 2] = std::max(0.0f, std::min(1.0f, bNew));
			}
		}
	}
	clutLibrary["Fujifilm Pro 400H (3D)"] = fujiPro3D;

	// Kodak Portra 400 3D CLUT (film emulation)
	CLUT portra3D;
	portra3D.name = "Kodak Portra 400 (3D)";
	portra3D.size = 16;
	portra3D.is3D = true;
	portra3D.data.resize(portra3D.size * portra3D.size * portra3D.size * 3);

	for (int b = 0; b < portra3D.size; b++)
	{
		for (int g = 0; g < portra3D.size; g++)
		{
			for (int r = 0; r < portra3D.size; r++)
			{
				int idx = (b * portra3D.size * portra3D.size + g * portra3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (portra3D.size - 1);
				float gNorm = static_cast<float>(g) / (portra3D.size - 1);
				float bNorm = static_cast<float>(b) / (portra3D.size - 1);

				// Portra is known for its warm, natural skin tones and muted colors
				float rNew = rNorm;
				float gNew = gNorm;
				float bNew = bNorm;

				// Softer shadow contrast
				if (rNorm < 0.3f)
					rNew = rNorm * 1.05f;
				if (gNorm < 0.3f)
					gNew = gNorm * 1.05f;
				if (bNorm < 0.3f)
					bNew = bNorm * 0.95f;

				// Warm midtones (slightly golden)
				if (rNorm >= 0.3f && rNorm < 0.7f)
				{
					rNew = std::min(1.0f, rNorm * 1.05f);
					gNew = std::min(1.0f, gNorm * 1.03f);
					bNew = std::min(1.0f, bNorm * 0.98f);
				}

				// Soft pastel highlights
				if (rNorm >= 0.7f)
				{
					rNew = std::min(1.0f, 0.9f + (rNorm - 0.7f) * 0.33f);
					gNew = std::min(1.0f, gNorm * 1.05f);
					bNew = std::min(1.0f, bNorm * 1.03f);
				}

				portra3D.data[idx + 0] = std::max(0.0f, std::min(1.0f, rNew));
				portra3D.data[idx + 1] = std::max(0.0f, std::min(1.0f, gNew));
				portra3D.data[idx + 2] = std::max(0.0f, std::min(1.0f, bNew));
			}
		}
	}
	clutLibrary["Kodak Portra 400 (3D)"] = portra3D;

	// Toon 3D CLUT (cel shading)
	CLUT toon3D;
	toon3D.name = "Toon (3D)";
	toon3D.size = 16;
	toon3D.is3D = true;
	toon3D.data.resize(toon3D.size * toon3D.size * toon3D.size * 3);

	// Define number of steps (bands) for cel shading effect
	const int numBands = 4;

	for (int b = 0; b < toon3D.size; b++)
	{
		for (int g = 0; g < toon3D.size; g++)
		{
			for (int r = 0; r < toon3D.size; r++)
			{
				int idx = (b * toon3D.size * toon3D.size + g * toon3D.size + r) * 3;

				float rNorm = static_cast<float>(r) / (toon3D.size - 1);
				float gNorm = static_cast<float>(g) / (toon3D.size - 1);
				float bNorm = static_cast<float>(b) / (toon3D.size - 1);

				// Quantize each color channel to create distinct bands
				float rQuant = std::floor(rNorm * numBands) / (numBands - 1);
				float gQuant = std::floor(gNorm * numBands) / (numBands - 1);
				float bQuant = std::floor(bNorm * numBands) / (numBands - 1);

				// Add slight boost to emphasize color transitions
				rQuant = std::min(1.0f, rQuant * 1.05f);
				gQuant = std::min(1.0f, gQuant * 1.05f);
				bQuant = std::min(1.0f, bQuant * 1.05f);

				// Calculate luminance
				float luminance = 0.2126f * rNorm + 0.7152f * gNorm + 0.0722f * bNorm;

				// Boost saturation to make colors more vibrant (cartoon-like)
				float saturationBoost = 1.2f;
				float luminanceWeight = 0.3f;

				rQuant = rQuant * (1.0f - luminanceWeight) + luminance * luminanceWeight;
				gQuant = gQuant * (1.0f - luminanceWeight) + luminance * luminanceWeight;
				bQuant = bQuant * (1.0f - luminanceWeight) + luminance * luminanceWeight;

				// Apply saturation boost
				float avgColor = (rQuant + gQuant + bQuant) / 3.0f;
				rQuant = avgColor + (rQuant - avgColor) * saturationBoost;
				gQuant = avgColor + (gQuant - avgColor) * saturationBoost;
				bQuant = avgColor + (bQuant - avgColor) * saturationBoost;

				toon3D.data[idx + 0] = std::max(0.0f, std::min(1.0f, rQuant));
				toon3D.data[idx + 1] = std::max(0.0f, std::min(1.0f, gQuant));
				toon3D.data[idx + 2] = std::max(0.0f, std::min(1.0f, bQuant));
			}
		}
	}
	clutLibrary["Toon (3D)"] = toon3D;
}
